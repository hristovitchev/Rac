<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Turbo Nova â€“ Mobile Racer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      touch-action: none; /* prevent scrolling on touch */
    }
    canvas {
      display: block;
    }
    /* Simple overlay instructions */
    #ui {
      position: fixed;
      left: 0;
      top: 0;
      width: 100%;
      color: #fff;
      text-shadow: 0 0 5px #000;
      font-size: 12px;
      padding: 6px 10px;
      box-sizing: border-box;
      pointer-events: none;
    }
    #ui .top {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    #ui .bottom {
      margin-top: 4px;
      opacity: 0.75;
      text-align: center;
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  <div id="ui">
    <div class="top">
      <div id="speed">Speed: 0</div>
      <div id="score">Score: 0</div>
      <div id="status"></div>
    </div>
    <div class="bottom">
      Tap LEFT / RIGHT to steer â€“ middle for BOOST
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const speedEl = document.getElementById('speed');
    const scoreEl = document.getElementById('score');
    const statusEl = document.getElementById('status');

    function resizeCanvas() {
      canvas.width = window.innerWidth * window.devicePixelRatio;
      canvas.height = window.innerHeight * window.devicePixelRatio;
      ctx.setTransform(window.devicePixelRatio, 0, 0, window.devicePixelRatio, 0, 0);
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // Game state
    let lastTime = 0;
    let running = true;

    let playerX = 0;     // -1 (left) to 1 (right)
    const playerSpeed = 1.6; // horizontal speed
    let baseSpeed = 0.35;    // forward speed
    let speed = baseSpeed;
    let boost = 0;
    let boostCooldown = 0;

    let score = 0;
    let difficultyTimer = 0;

    const obstacles = [];
    let spawnTimer = 0;

    const input = {
      left: false,
      right: false,
      boost: false
    };

    // Touch controls for mobile
    function handleTouchStart(e) {
      e.preventDefault();
      input.left = false;
      input.right = false;
      input.boost = false;
      const w = window.innerWidth;

      for (let i = 0; i < e.touches.length; i++) {
        const x = e.touches[i].clientX;
        if (x < w * 0.33) {
          input.left = true;
        } else if (x > w * 0.66) {
          input.right = true;
        } else {
          input.boost = true;
        }
      }
    }

    function handleTouchEnd(e) {
      e.preventDefault();
      // Recalculate from remaining touches
      input.left = false;
      input.right = false;
      input.boost = false;
      const w = window.innerWidth;
      for (let i = 0; i < e.touches.length; i++) {
        const x = e.touches[i].clientX;
        if (x < w * 0.33) {
          input.left = true;
        } else if (x > w * 0.66) {
          input.right = true;
        } else {
          input.boost = true;
        }
      }
    }

    window.addEventListener('touchstart', handleTouchStart, { passive: false });
    window.addEventListener('touchmove', handleTouchStart, { passive: false });
    window.addEventListener('touchend', handleTouchEnd, { passive: false });
    window.addEventListener('touchcancel', handleTouchEnd, { passive: false });

    // Keyboard for desktop testing
    window.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowLeft' || e.key === 'a') input.left = true;
      if (e.key === 'ArrowRight' || e.key === 'd') input.right = true;
      if (e.key === ' ' || e.key === 'ArrowUp') input.boost = true;
      if (e.key === 'r') resetGame();
    });
    window.addEventListener('keyup', (e) => {
      if (e.key === 'ArrowLeft' || e.key === 'a') input.left = false;
      if (e.key === 'ArrowRight' || e.key === 'd') input.right = false;
      if (e.key === ' ' || e.key === 'ArrowUp') input.boost = false;
    });

    function resetGame() {
      playerX = 0;
      baseSpeed = 0.35;
      speed = baseSpeed;
      boost = 0;
      boostCooldown = 0;
      score = 0;
      difficultyTimer = 0;
      obstacles.length = 0;
      spawnTimer = 0;
      running = true;
      statusEl.textContent = '';
    }

    function spawnObstacle() {
      // x in [-0.8, 0.8], y depth 0 (top), size factor
      const x = (Math.random() * 1.6) - 0.8;
      const size = 0.08 + Math.random() * 0.04; // width relative to road
      obstacles.push({
        x,
        y: 0,
        size,
        color: Math.random() < 0.5 ? '#ff3366' : '#33ccff'
      });
    }

    function update(dt) {
      if (!running) return;

      // dt in seconds
      const moveDir = (input.right ? 1 : 0) - (input.left ? 1 : 0);
      playerX += moveDir * playerSpeed * dt;
      // Soft clamp
      if (playerX < -1) playerX = -1;
      if (playerX > 1) playerX = 1;

      // Boost handling
      boostCooldown -= dt;
      if (boostCooldown < 0) boostCooldown = 0;
      if (input.boost && boost <= 0 && boostCooldown === 0) {
        boost = 1.2; // seconds of boost
        boostCooldown = 3.0; // seconds before next boost
      }

      if (boost > 0) {
        boost -= dt;
        speed = baseSpeed * 2.0;
      } else {
        speed = baseSpeed;
      }

      // Forward progress
      score += speed * 40 * dt;
      difficultyTimer += dt;

      // Gradually increase difficulty
      baseSpeed = 0.35 + difficultyTimer * 0.02; // gets faster over time
      spawnTimer -= dt;
      if (spawnTimer <= 0) {
        spawnObstacle();
        const minInterval = 0.25;
        const maxInterval = 0.8;
        const t = Math.max(0, 1 - difficultyTimer * 0.1);
        spawnTimer = minInterval + t * (maxInterval - minInterval);
      }

      // Update obstacles
      for (let i = obstacles.length - 1; i >= 0; i--) {
        const o = obstacles[i];
        o.y += speed * dt;
        if (o.y > 1.2) {
          obstacles.splice(i, 1);
          continue;
        }
      }

      // Collision detection
      // When obstacles are near bottom (y > 0.8), compare lateral distance
      const collisionDepth = 0.9;
      const playerWidth = 0.18;
      for (let i = 0; i < obstacles.length; i++) {
        const o = obstacles[i];
        if (o.y > 0.82 && o.y < 1.05) {
          const dx = Math.abs(o.x - playerX);
          const combinedHalf = (playerWidth + o.size) * 0.5;
          if (dx < combinedHalf * 1.05) {
            // soft "crash" â€“ reduce speed & score, but no game over
            baseSpeed *= 0.7;
            statusEl.textContent = 'ðŸ’¥ Ouch! You clipped a car!';
            statusEl.style.color = '#ff6666';
          }
        }
      }

      // UI
      speedEl.textContent = 'Speed: ' + Math.round(speed * 180);
      scoreEl.textContent = 'Score: ' + Math.round(score);
      if (boost > 0) {
        statusEl.textContent = 'ðŸš€ BOOST!';
        statusEl.style.color = '#66ffcc';
      } else if (!statusEl.textContent.startsWith('ðŸ’¥')) {
        statusEl.textContent = '';
      }
    }

    function drawRoad() {
      const w = canvas.width / window.devicePixelRatio;
      const h = canvas.height / window.devicePixelRatio;

      // Background
      const grad = ctx.createLinearGradient(0, 0, 0, h);
      grad.addColorStop(0, '#020515');
      grad.addColorStop(1, '#050b22');
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, w, h);

      // Road coordinates (trapezoid)
      const horizon = h * 0.35;
      const bottom = h * 1.05;

      const topLeft = w * 0.33;
      const topRight = w * 0.67;
      const bottomLeft = w * 0.05;
      const bottomRight = w * 0.95;

      // Road body
      ctx.beginPath();
      ctx.moveTo(bottomLeft, bottom);
      ctx.lineTo(bottomRight, bottom);
      ctx.lineTo(topRight, horizon);
      ctx.lineTo(topLeft, horizon);
      ctx.closePath();
      ctx.fillStyle = '#111';
      ctx.fill();

      // Road edges
      ctx.lineWidth = 4;
      ctx.strokeStyle = '#444';
      ctx.beginPath();
      ctx.moveTo(bottomLeft, bottom);
      ctx.lineTo(topLeft, horizon);
      ctx.moveTo(bottomRight, bottom);
      ctx.lineTo(topRight, horizon);
      ctx.stroke();

      // Lane center lines (faux perspective)
      ctx.lineWidth = 2;
      ctx.setLineDash([10, 18]);
      ctx.strokeStyle = '#999';
      ctx.beginPath();
      const segments = 16;
      for (let i = 0; i < segments; i++) {
        const t1 = i / segments;
        const t2 = (i + 1) / segments;
        const y1 = horizon + (bottom - horizon) * t1;
        const y2 = horizon + (bottom - horizon) * t2;
        const midLeft1 = topLeft + (bottomLeft - topLeft) * t1;
        const midRight1 = topRight + (bottomRight - topRight) * t1;
        const midLeft2 = topLeft + (bottomLeft - topLeft) * t2;
        const midRight2 = topRight + (bottomRight - topRight) * t2;

        const centerX1 = (midLeft1 + midRight1) * 0.5;
        const centerX2 = (midLeft2 + midRight2) * 0.5;
        ctx.moveTo(centerX1, y1);
        ctx.lineTo(centerX2, y2);
      }
      ctx.stroke();
      ctx.setLineDash([]);

      return { horizon, bottom, topLeft, topRight, bottomLeft, bottomRight };
    }

    function projectOnRoad(depth, lateral, road) {
      // depth: 0 (horizon) to 1 (bottom)
      const { horizon, bottom, topLeft, topRight, bottomLeft, bottomRight } = road;
      const y = horizon + (bottom - horizon) * depth;
      const left = topLeft + (bottomLeft - topLeft) * depth;
      const right = topRight + (bottomRight - topRight) * depth;
      const x = left + (lateral * 0.5 + 0.5) * (right - left); // lateral -1..1

      const width = (right - left);
      return { x, y, width };
    }

    function drawPlayer(road) {
      const pos = projectOnRoad(0.98, playerX, road);
      const carWidth = pos.width * 0.12;
      const carHeight = carWidth * 1.4;

      ctx.save();
      ctx.translate(pos.x, pos.y);
      ctx.beginPath();
      ctx.moveTo(-carWidth * 0.5, 0);
      ctx.lineTo(carWidth * 0.5, 0);
      ctx.lineTo(carWidth * 0.35, -carHeight);
      ctx.lineTo(-carWidth * 0.35, -carHeight);
      ctx.closePath();
      const carGrad = ctx.createLinearGradient(-carWidth, -carHeight, carWidth, 0);
      carGrad.addColorStop(0, '#33ffcc');
      carGrad.addColorStop(1, '#0077ff');
      ctx.fillStyle = carGrad;
      ctx.fill();

      // Windshield
      ctx.fillStyle = '#001122';
      ctx.fillRect(-carWidth * 0.28, -carHeight * 0.7, carWidth * 0.56, carHeight * 0.35);

      // Outline
      ctx.lineWidth = 2;
      ctx.strokeStyle = '#0ff';
      ctx.stroke();
      ctx.restore();
    }

    function drawObstacles(road) {
      for (let i = 0; i < obstacles.length; i++) {
        const o = obstacles[i];
        const pos = projectOnRoad(o.y, o.x, road);
        const carWidth = pos.width * o.size;
        const carHeight = carWidth * 1.3;

        ctx.save();
        ctx.translate(pos.x, pos.y);
        ctx.beginPath();
        ctx.moveTo(-carWidth * 0.5, 0);
        ctx.lineTo(carWidth * 0.5, 0);
        ctx.lineTo(carWidth * 0.36, -carHeight);
        ctx.lineTo(-carWidth * 0.36, -carHeight);
        ctx.closePath();

        ctx.fillStyle = o.color;
        ctx.fill();

        ctx.lineWidth = 1.5;
        ctx.strokeStyle = '#fff';
        ctx.stroke();
        ctx.restore();
      }
    }

    function drawBoostOverlay() {
      if (boost <= 0) return;
      const w = canvas.width / window.devicePixelRatio;
      const h = canvas.height / window.devicePixelRatio;
      const alpha = Math.min(0.28, 0.1 + boost * 0.2);
      ctx.fillStyle = 'rgba(0, 255, 200,' + alpha + ')';
      ctx.fillRect(0, 0, w, h);
    }

    function drawVignette() {
      const w = canvas.width / window.devicePixelRatio;
      const h = canvas.height / window.devicePixelRatio;
      const grd = ctx.createRadialGradient(
        w / 2, h * 0.6, h * 0.05,
        w / 2, h * 0.6, h * 0.75
      );
      grd.addColorStop(0, 'rgba(0,0,0,0)');
      grd.addColorStop(1, 'rgba(0,0,0,0.75)');
      ctx.fillStyle = grd;
      ctx.fillRect(0, 0, w, h);
    }

    function loop(timestamp) {
      if (!lastTime) lastTime = timestamp;
      const dt = (timestamp - lastTime) / 1000; // seconds
      lastTime = timestamp;

      update(dt);

      const road = drawRoad();
      drawObstacles(road);
      drawPlayer(road);
      drawBoostOverlay();
      drawVignette();

      requestAnimationFrame(loop);
    }

    resetGame();
    requestAnimationFrame(loop);
  </script>
</body>
</html>
